XWB_CSK_Tool.pyw

"""
AIRBUS A350 Nonconformity Tool

Database by YI Yuwen (yi_yuwen@airbus.com)
Programming by ZHANG Yifan (zhang_yf@airbus.com)

"""

import sys
import os

from PyQt5.QtWidgets import *

import xwbt

# Initialize mdb
xwbt.core.db.IniMDB()

# for debug only
# Delete before release
def GetPyFilePath(folder):
    file_path = []
    files = os.listdir(folder)

    for n in files:
        path = '%s/%s' %(folder, n)
        if os.path.isfile(path):
            if os.path.splitext(path)[1] == '.py':
                file_path.append(path)
    return file_path

if 1:
    folders = [xwbt.mdb.package_path]
    raw = os.listdir(xwbt.mdb.package_path)
    try:
        raw.remove('docx')
    except:
        pass
    for n in raw:
        if not os.path.isfile('%s/%s' % (xwbt.mdb.package_path, n)):
            folders.append('%s/%s' % (xwbt.mdb.package_path, n))
    py_file_paths = []
    for n in folders:
        py_file_paths += GetPyFilePath(n)
    total_line_no = 0
    for n in py_file_paths:
        try:
            with open(n, 'r') as f:
                total_line_no += len(f.readlines())
        except:
            pass
    print('Line number: %d' % total_line_no)
# end of debug only

# Start the GUI
app = QApplication(sys.argv)
xwbt.mdb.window = xwbt.gui.main_window.MainWindow()
xwbt.mdb.window.Start()
xwbt.mdb.window.show()
app.exec_()

core
__init__.py
from . import db
from . import common
from . import report_generator

#for debug
from . import parser

common.py
#

import scipy.interpolate
import copy

from .. import mdb

def GetProjectorfromView(view_flag):
    """
    This function is to define the projection parameters of
    converting the fastener coordinates from 3D absolute
    axis to 2D Graphicsview axis.
    """

    # projector = [[two axises to remain],[direction of the two axises],
    # filter of the third axis]
    projector = []

    if view_flag == 'from_top':
        projector = [[0, 1], ['along', 'reversed'], 'positive']
    elif view_flag == 'from_below':
        projector = [[0, 1], ['along', 'along'], 'negative']
    elif view_flag == 'from_left':
        projector = [[0, 2], ['along', 'reversed'], 'negative']
    elif view_flag == 'from_right':
        projector = [[0, 2], ['reversed', 'reversed'], 'positive']
    return projector

def ProjectFastenerbyPlane(fasteners, projector):
    axises = [0, 1, 2]
    for n in projector[0]:
        axises.remove(n)
    third_axis = axises[0]

    # f_projected['fastener_id']=[a.b]
    f_projected = {}
    if third_axis == 2:
        neutral_value = mdb.neutral_z
    else:
        neutral_value = 0.0
    for n in fasteners.keys():
        validity = False
        if (projector[2] == 'positive') and (fasteners[n]['coordinate'][third_axis] >= neutral_value):
            validity = True
        elif (projector[2] == 'negative') and (fasteners[n]['coordinate'][third_axis] <= neutral_value):
            validity = True

        if validity:
            coordinate_projected = [fasteners[n]['coordinate'][m] for m in projector[0]]
            for m in range(0, 2):
                if projector[1][m] == 'reversed':
                    coordinate_projected[m] = -coordinate_projected[m]
            f_projected[n] = coordinate_projected
    return f_projected

def MapFastener2Scene(f_projected, boundary_margin = (50, 50)):
    # This function is to be executed after ProjectFastenerbyPlane()
    # This function is to translate the projected fastener coordinates from absolute axis to scene axis,
    # and gives the boundary of the scene.
    xy=[[], []]
    for n in f_projected.keys():
        xy[0].append(f_projected[n][0])
        xy[1].append(f_projected[n][1])
    shift = [min(xy[0]) - boundary_margin[0], min(xy[1]) - boundary_margin[1]]

    f_translated = {}
    for n in f_projected.keys():
        f_translated[n] = [f_projected[n][0]-shift[0], f_projected[n][1]-shift[1]]

    boundary = [max(xy[0]) + boundary_margin[0] - shift[0], max(xy[1]) + boundary_margin[1] - shift[1]]
    return [f_translated, shift, boundary]

def ProjectSTGR(stringers, projector, view_flag):
    stgr_projected = {}
    for n in stringers['data'].keys():
        # Left part
        filted = True
        for p in mdb.stgr_shown[view_flag]:
            if n in [j for j in range(p[0],p[1]+1)]:
                filted = False
        if not filted:
            stgr_projected[n] = []
            for m in range(0, len(stringers['data'][n]['points'])):
                point = []
                for j in range(0, 2):
                    point.append(stringers['data'][n]['points'][m][projector[0][j]])
                    if projector[1][j] == 'reversed':
                        point[j] = -point[j]
                stgr_projected[n].append(point)
        # Right part
        filted = True
        for p in mdb.stgr_shown[view_flag]:
            if -int(n) in [j for j in range(p[0],p[1]+1)]:
                filted = False
        if not filted:
            new_label = -int(n)
            stgr_projected[new_label] = []
            for m in range(0, len(stringers['data'][n]['points'])):
                point = []
                ori_coor = copy.deepcopy(stringers['data'][n]['points'][m])
                ori_coor[1] = -ori_coor[1]
                for j in range(0, 2):
                    point.append(ori_coor[projector[0][j]])
                    if projector[1][j] == 'reversed':
                        point[j] = -point[j]
                stgr_projected[new_label].append(point)
    return stgr_projected

def TranslateSTGR(stgr_projected, shift):
    stgr_translated = {}
    for n in stgr_projected.keys():
        stgr_translated[n] = []
        for m in range(0, len(stgr_projected[n])):
            stgr_translated[n].append([stgr_projected[n][m][0]-shift[0],
                                       stgr_projected[n][m][1]-shift[1]])
    return stgr_translated

def TranslateFR(frs, projector, shift):
    direction = projector[1][projector[0].index(0)]
    frs_translated = copy.deepcopy(frs)
    if direction == 'reversed':
        for n in frs_translated['data'].keys():
            frs_translated['data'][n]['x'] = -frs_translated['data'][n]['x']
    for n in frs_translated['data'].keys():
        frs_translated['data'][n]['x'] = frs_translated['data'][n]['x'] - shift[0]
    return frs_translated

def FilterFastenerbySTGR(f_projected, boundary_stgr, stgr_projected):
    # boundary_stgr=[upper_stgr_str,lower_stgr_str]

    stgr_tmp = copy.deepcopy(stgr_projected)
    for n in stgr_tmp.keys():
        if stgr_tmp[n][0] > stgr_tmp[n][1]:
            stgr_tmp[n].reverse()

    ids = list(f_projected.keys())
    # Step one, remove fasteners higher than the highest point
    # of the upper boundary stringer; lower than the lowest
    # point of the lower boundary stringer.
    ids_out = []
    ys_upper = []
    for n in range(0, len(stgr_tmp[boundary_stgr[0]])):
        ys_upper.append(stgr_tmp[boundary_stgr[0]][n][1])
    ys_lower = []
    for n in range(0, len(stgr_tmp[boundary_stgr[1]])):
        ys_lower.append(stgr_tmp[boundary_stgr[1]][n][1])
    y_max = max(ys_lower)
    y_min = min(ys_upper)
    for n in ids:
        if f_projected[n][1] > y_max or f_projected[n][1] < y_min:
            ids_out.append(n)

    # Step two, pass fasteners between the lower point of the
    # upper boundary stringer and the upper point of the
    # lower boundary stringer.
    ids_in = []
    y_max = min(ys_lower)
    y_min = max(ys_upper)
    for n in ids:
        if f_projected[n][1] <= y_max and f_projected[n][1] >= y_min:
            ids_in.append(n)

    # Step three, for rest of the points, check their location
    upper_boundary_curve = [[], []]
    for n in stgr_tmp[boundary_stgr[0]]:
        for m in range(0, 2):
            upper_boundary_curve[m].append(n[m])
    lower_boundary_curve = [[], []]
    for n in stgr_tmp[boundary_stgr[1]]:
        for m in range(0, 2):
            lower_boundary_curve[m].append(n[m])
    upper_interp = scipy.interpolate.interp1d(upper_boundary_curve[0], upper_boundary_curve[1])
    lower_interp = scipy.interpolate.interp1d(lower_boundary_curve[0], lower_boundary_curve[1])
    for n in ids_out:
        if n in ids:
            ids.remove(n)
    for n in ids_in:
        if n in ids:
            ids.remove(n)
    y_max = min(ys_lower)
    y_min = max(ys_upper)
    for n in ids:
        validity = False
        if f_projected[n][1] <= y_min:
            # fastener locates to upper half
            if f_projected[n][0] < stgr_tmp[boundary_stgr[0]][0][0]:
                if f_projected[n][1] >= stgr_tmp[boundary_stgr[0]][0][1]:
                    validity = True
            elif f_projected[n][0] > stgr_tmp[boundary_stgr[0]][-1][0]:
                if f_projected[n][1] >= stgr_tmp[boundary_stgr[0]][-1][1]:
                    validity = True
            else:
                if f_projected[n][1] >= upper_interp(f_projected[n][0]):
                    validity = True
        elif f_projected[n][1] >= y_max:
            # fastener locates at lower half
            if f_projected[n][0] < stgr_tmp[boundary_stgr[1]][0][0]:
                if f_projected[n][1] <= stgr_tmp[boundary_stgr[1]][0][1]:
                    validity = True
            elif f_projected[n][0] > stgr_tmp[boundary_stgr[1]][-1][0]:
                if f_projected[n][1] <= stgr_tmp[boundary_stgr[1]][-1][1]:
                    validity = True
            else:
                if f_projected[n][1] <= lower_interp(f_projected[n][0]):
                    validity = True
        if validity:
            ids_in.append(n)
    return ids_in

def GridFasteners(fasteners, boundary, radius=10.0):
    # This function divides the fasteners into grids to improve
    # performance when checking the mouse hovring over action.

    grid_number = 10
    # find boundaries
    ids = fasteners.keys()
    grid = {'h_divider':[],
            'v_divider':[],
            'ids':[]}
    for v_grid in range(0, grid_number):
        grid['v_divider'].append(float(v_grid) * boundary[1] / float(grid_number))
    for h_grid in range(0, grid_number):
        grid['h_divider'].append(float(h_grid)*boundary[0]/float(grid_number))
        grid['ids'].append([])
        h_bound = [float(h_grid) * boundary[0] / float(grid_number) - radius,
                   float(h_grid+1) * boundary[0] / float(grid_number) + radius]
        for v_grid in range(0, grid_number):
            grid['ids'][h_grid].append([])
            v_bound = [float(v_grid) * boundary[1] / float(grid_number) - radius,
                       float(v_grid+1) * boundary[1] / float(grid_number) + radius]
            for n in fasteners.keys():
                if (fasteners[n][0] >= h_bound[0]) and (fasteners[n][0] <= h_bound[1]):
                    if (fasteners[n][1] >= v_bound[0]) and (fasteners[n][1] <= v_bound[1]):
                        grid['ids'][h_grid][v_grid].append(n)

    return grid

def FRLines(frs, boundary_stgr, stgr_projected):
    stgr_tmp = copy.deepcopy(stgr_projected)
    for n in stgr_tmp.keys():
        if stgr_tmp[n][0] > stgr_tmp[n][1]:
            stgr_tmp[n].reverse()
    upper_boundary_curve = [[], []]
    for n in stgr_tmp[boundary_stgr[0]]:
        for m in range(0, 2):
            upper_boundary_curve[m].append(n[m])
    lower_boundary_curve = [[], []]
    for n in stgr_tmp[boundary_stgr[1]]:
        for m in range(0, 2):
            lower_boundary_curve[m].append(n[m])
    upper_interp = scipy.interpolate.interp1d(upper_boundary_curve[0], upper_boundary_curve[1])
    lower_interp = scipy.interpolate.interp1d(lower_boundary_curve[0], lower_boundary_curve[1])

    fr_limits = {}
    for n in frs['data'].keys():
        fr_limits[n] = []
        fr_limits[n].append(upper_interp(frs['data'][n]['x']))
        fr_limits[n].append(lower_interp(frs['data'][n]['x']))
    return fr_limits

def GetFastenerIDsbyPicture(pic_name, side_flag):
    ids = []
    if side_flag == 'lh':
        for n in mdb.fasteners.keys():
            if mdb.fasteners[n]['picture'] == pic_name:
                if mdb.fasteners[n]['coordinate'][1] <= 0:
                    ids.append(n)
    elif side_flag == 'rh':
        for n in mdb.fasteners.keys():
            if mdb.fasteners[n]['picture'] == pic_name:
                if mdb.fasteners[n]['coordinate'][1] >= 0:
                    ids.append(n)
    elif side_flag == 'both':
        for n in mdb.fasteners.keys():
            if mdb.fasteners[n]['picture'] == pic_name:
                ids.append(n)
    return ids

def ProjectFasteners2Pic(ids, projector):
    """
    This function will project the fasteners to the picture
    with the top left fastener at the top left pixel of the picture
    """

    # projector = [[int of the two remained axis], [along/reverse of the two axis]]

    # Pojection to picture axises and directions
    projected = {}
    for n in ids:
        projected[n] = []
        for m in range(0, 2):
            if projector[1][m] == 'along':
                projected[n].append(copy.deepcopy(mdb.fasteners[n]['coordinate'][projector[0][m]]))
            else:
                projected[n].append(-copy.deepcopy(mdb.fasteners[n]['coordinate'][projector[0][m]]))
    return projected

def FindCornerFasteners(projected):
    """
    This function will return the top left/ bottom right point ids from
    the projected point coordinates.
    """

    ids = list(projected.keys())
    # Find envelope
    xs = []
    ys = []
    for n in ids:
        xs.append(projected[n][0])
        ys.append(projected[n][1])
    x_lim = [min(xs), max(xs)]
    y_lim = [min(ys), max(ys)]

    # Find corner points
    distances = []
    for n in ids:
        dis = abs(projected[n][0] + projected[n][1] - x_lim[0] - y_lim[0]) / (2.0 ** 0.5)
        distances.append(dis)
    top_left_point_id = ids[distances.index(min(distances))]
    distances = []
    for n in ids:
        dis = abs(projected[n][0] + projected[n][1] - x_lim[1] - y_lim[1]) / (2.0 ** 0.5)
        distances.append(dis)
    bottom_right_point_id = ids[distances.index(min(distances))]
    return [top_left_point_id, bottom_right_point_id]

db.py

import configparser

from .. import mdb
from . import parser

def IniMDB():
    # Initialize an empty NC object
    mdb.ncs = [NC()]
    mdb.current_nc_index = 0

    # Read the database
    parser.Parser()

class NC():
    def __init__(self):
        self.number = None
        self.msn = None
        self.divergence_type = None
        self.divergence_info = None

    def SetDivergence(self, flag):
        if flag == 'deep_csk':
            self.divergence_info = DeepCSK()

class DeepCSK():
    def __init__(self):
        self.affected_fasteners = {'ids': [], 'depth': []}

parser.py
# come on, write something...

import os
import pickle
import hashlib

import xlrd

from .. import mdb

# develop notes:
# check hash of the database file, if no change, read from pickle

def DatabaseFormat():
    # This function is to define the file name/columns/rows of
    # each data.
    fm = {}

    fm['file_name'] = 'DATABASE_V1.2.xlsm'

    fm['fastener_tab'] = {}
    fm['fastener_tab']['sheet_name'] = 'RIVET_INFO'
    fm['fastener_tab']['starting_row'] = 1
    fm['fastener_tab']['xyz_columns'] = (1,2,3)
    fm['fastener_tab']['type_column'] = 7
    fm['fastener_tab']['zone'] = 9
    fm['fastener_tab']['picture'] = 8

    fm['frame_tab'] = {}
    fm['frame_tab']['sheet_name'] = 'FR_COORDINATE'
    fm['frame_tab']['starting_row'] = 1
    fm['frame_tab']['name_column'] = 0
    fm['frame_tab']['x_column'] = 1

    fm['stgr_tab'] = {}
    fm['stgr_tab']['sheet_name'] = 'STGR_COORDINATE'
    fm['stgr_tab']['starting_row'] = 1

    fm['zone_tab'] = {}
    fm['zone_tab']['sheet_name'] = 'Drawing_Pic_Info'
    fm['zone_tab']['starting_row'] = 1
    fm['zone_tab']['zone_column'] = 0
    fm['zone_tab']['picture_column'] = 1

    return fm

def HashDatabase():
    return

def FetchFastenerInfo(wb, fm):
    # Fetch fastener information
    # [id]['coordinate'] = [x,y,z]
    #     ['type'] = [list of four str]
    #     ['zone'] = str
    #     ['picture'] = str
    fm_f = fm['fastener_tab']
    rivet_info_sheet = wb.sheet_by_name(fm_f['sheet_name'])

    fastener_id = 0
    fasteners = {}
    row_no = rivet_info_sheet.nrows
    for n in range(fm_f['starting_row'], row_no):
        # Determine end of the sheet
        if rivet_info_sheet.cell(n, 0).value == '':
            break

        # Store the information
        fasteners[fastener_id] = {}
        # type
        raw = rivet_info_sheet.cell(n,fm_f['type_column']).value.upper()
        fasteners[fastener_id]['type'] = raw.split(';')
        # coordinates
        fasteners[fastener_id]['coordinate'] = []
        for m in fm_f['xyz_columns']:
            fasteners[fastener_id]['coordinate'].append(rivet_info_sheet.cell(n, m).value)
        # zone
        fasteners[fastener_id]['zone'] = rivet_info_sheet.cell(n, fm_f['zone']).value
        # picture
        fasteners[fastener_id]['picture'] = rivet_info_sheet.cell(n, fm_f['picture']).value

        fastener_id += 1
    # print(len(fasteners.keys()))
    return fasteners

def FetchFrames(wb, fm):
    # Fetch the Frames
    # Frames are presented as names and x coordinates.
    # (error will happen if none integer frame names appear)
    # ['int_list'] = [int frame number in list (increasing order)]
    # ['data'] = [int as id]['x'] = float
    fm_f = fm['frame_tab']
    fr_sheet = wb.sheet_by_name(fm_f['sheet_name'])

    frames = {'int_list': [], 'data': {}}
    row_no = fr_sheet.nrows
    for n in range(fm_f['starting_row'], row_no):
        # Determine the end of the sheet
        if fr_sheet.cell(n, 0).value == '':
            break

        # Store the information
        # name
        name_int = int(fr_sheet.cell(n, fm_f['name_column']).value)
        frames['int_list'].append(name_int)
        # x coordinate
        frames['data'][name_int] = {}
        frames['data'][name_int]['x'] = float(fr_sheet.cell(n, fm_f['x_column']).value)
    return frames

def FetchStringers(wb, fm):
    # Fetch the stringers
    # Stringers are presented in a series of discrete points.
    # NOTE: Stringers in A350 are symmetry for LH and RH.
    # The discrete points in the database are for LH.
    # (error will eppear if none integer stringer names appear.)
    # ['int_list'] = [int stgr number in list (increasing order)]
    # ['data'][name_int]['points'] = [coordinates as lists]
    fm_s = fm['stgr_tab']
    stgr_sheet = wb.sheet_by_name(fm_s['sheet_name'])

    # find the column and row numbers of the sheet
    row_no = stgr_sheet.nrows
    col_no = stgr_sheet.ncols
    real_row_no = 1
    for n in range(0, row_no):
        if stgr_sheet.cell(n, 0).value == '':
            break
        else:
            real_row_no += 1
    if row_no > real_row_no:
        row_no = real_row_no
    real_col_no = 0
    for n in range(0, col_no):
        if stgr_sheet.cell(0, n).value == '':
            break
        else:
            real_col_no += 1
    if col_no > real_col_no:
        col_no = real_col_no

    stgrs = {'int_list':[], 'data':{}}
    # find stringer names
    for n in range(0, int(col_no/4)):
        name_str = str(stgr_sheet.cell(0, 4*n).value)
        name_int = int(''.join(ch for ch in name_str if ch.isdigit()))
        stgrs['int_list'].append(name_int)
        stgrs['data'][name_int] = {'points':[]}
    # find the points
    for n in range(0, int(col_no/4)):
        col_pointer = 4 * n + 1
        for m in range(fm_s['starting_row'], row_no):
            xyz = [float(stgr_sheet.cell(m, col_pointer + j).value) for j in range(0, 3)]
            stgrs['data'][stgrs['int_list'][n]]['points'].append(xyz)
    return stgrs

def ChecPicValidity():
    file_ext = '.jpg'

    # Summarize all pictures
    pictures = []
    for n in mdb.fasteners.keys():
        if not mdb.fasteners[n]['picture'] == '':
            pictures.append(mdb.fasteners[n]['picture'])
    pictures = list(set(pictures))

    # Check existences of the pictures
    folder_path = mdb.package_path + '\\data\\Drawing_Pictures\\'
    existences = []
    for n in pictures:
        if os.path.exists(folder_path + n +file_ext):
            existences.append(True)
        else:
            existences.append(False)
    return [pictures, existences]

def ParseDatabase(db_path, fm):
    # Open database and the validity check
    if not os.path.exists(db_path):
        return [-1, 'No database file found.']
    try:
        wb = xlrd.open_workbook(db_path)
    except:
        return [-2, 'Database broken.']

    '''
    tabs = ('Rivet Info', 'FR','STGR','Zone')
    tab_names=wb.sheet_names()
    for n in tabs:
        if not n in tab_names:
            return [-3,'Incomplete database.']
    '''

    db = {}
    db['fasteners'] = FetchFastenerInfo(wb, fm)
    db['frames'] = FetchFrames(wb, fm)
    db['stringers'] = FetchStringers(wb, fm)
    # further data to be added
    return [0,db]

def FindNeutralZ(fasteners):
    # It is observed that due to the S19 is quite high in Z-axis, filtering the fasteners by the
    # sign of Z value will lead to incorrect results.
    neutral_z = 0.0
    for n in fasteners.keys():
        neutral_z = neutral_z + fasteners[n]['coordinate'][2]
    neutral_z = neutral_z/float(len(fasteners.keys()))
    return neutral_z

def Parser():
    fm = DatabaseFormat()
    db_path = mdb.package_path + '\\data\\' + fm['file_name']
    [status,flag]=ParseDatabase(db_path, fm)

    if not status == 0:
        print(status,flag)
    if 'fasteners' in flag.keys():
        mdb.fasteners = flag['fasteners']
    if 'frames' in flag.keys():
        mdb.frames = flag['frames']
    if 'stringers' in flag.keys():
        mdb.stringers = flag['stringers']

    """
    # Find fasteners envelope
    fastener_ids = mdb.fasteners.keys()
    xyzs=[[],[],[]]
    for n in fastener_ids:
        coor=mdb.fasteners[n]['coordinate']
        for m in range(0,len(coor)):
            xyzs[m].append(coor[m])
    mdb.fastener_env=[]
    for n in range(0,len(xyzs)):
        mdb.fastener_env.append([min(xyzs[n]),max(xyzs[n])])
    """
    mdb.neutral_z = FindNeutralZ(mdb.fasteners)
    # print(mdb.neutral_z)

    # Check existence of drawing picture
    [pictures, existences] = ChecPicValidity()

gui
__init__.py
from . import main_window

fastener_selection_tab.py
"""
This file contains xxxx

"""

# to do:
# show different fastener mark for different fastener type.
# change line width during zoom in/out.

from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtCore import *

from .. import mdb
from .. import core

class FastenerSelectionTab():
    def __init__(self):
        self.IniParameters()
        self.IniUIElements()
        self.DrawTab()

    def IniParameters(self):
        # Set initial/default view as from left and generate projector accordingly.
        self.view = 'from_left'
        self.projector = core.common.GetProjectorfromView(self.view)

        # Initial NC database as a None.
        self.nc = None

        self.EmptyVar()

    def IniUIElements(self):
        self.gview = FastenerViewer(self)
        self.gscene = QGraphicsScene()
        self.gview.setScene(self.gscene)
        self.gscene.setBackgroundBrush(QColor(0,0,0))

        self.div_table=QTableWidget(1, 3)
        header = ['No.', 'Depth [mm]', 'Fastener Type']
        self.div_table.setHorizontalHeaderLabels(header)
        self.div_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.div_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.div_table.verticalHeader().hide()

        self.up_button=QPushButton('Up')
        self.down_button=QPushButton('Down')
        self.delete_button=QPushButton('Delete')
        self.projection_combo=ViewCombo(self)
        self.projection_combo.currentIndexChanged.connect(self.projection_combo.ChangeView)

    def DrawTab(self):
        view_grid = QGridLayout()
        view_grid.addWidget(QLabel('View Direction:'), 0, 0)
        view_grid.addWidget(self.projection_combo, 0, 1)
        view_group = QGroupBox('Select View')
        view_group.setLayout(view_grid)
        view_group.setFixedWidth(300)

        table_button_layout = QHBoxLayout()
        table_button_layout.addStretch()
        table_button_layout.addWidget(self.up_button)
        table_button_layout.addWidget(self.down_button)
        table_button_layout.addWidget(self.delete_button)

        div_table_group = QGroupBox('Affected Fasteners')
        div_table_layout = QVBoxLayout()
        div_table_layout.addWidget(self.div_table)
        div_table_layout.addLayout(table_button_layout)
        div_table_group.setLayout(div_table_layout)
        div_table_group.setFixedWidth(300)

        left_layout = QVBoxLayout()
        left_layout.addWidget(view_group)
        left_layout.addWidget(div_table_group)

        tab_layout=QHBoxLayout()
        tab_layout.addLayout(left_layout)
        tab_layout.addWidget(self.gview)

        self.tab_widget=QWidget()
        self.tab_widget.setLayout(tab_layout)

    def EmptyView(self):
        self.gscene.clear()
        self.gscene.invalidate(self.gscene.sceneRect())

    def EmptyVar(self):
        # This function is to empty the local variables when changing the view.
        # Will be executed at initialisation of the tab and changing of view combo box.

        # Set empty dics of the QGraphicsItems for fasteners/STGRs/FRs
        self.fastener_items = {}
        self.stringer_items = {}
        self.fr_items = []

        # Set empty position variables for fasteners/STGRs/FRs
        self.fastener_pos = {}
        self.stgr_pos = {}
        self.fr_pos = {}

        # Set empty variables of shifting values of fasteners/STGRs/FRs
        self.shift = []
        self.boundary = []

        self.hovering_over_id = None
        self.hovering_over_tip_items = []

        self.af_tip_items = {}

        self.rect_select_items = []

    def RefreshData(self, view_flag):
        self.EmptyVar()

        # Obtain projector from view
        self.view = view_flag
        self.projector = core.common.GetProjectorfromView(view_flag)

        # Project and translate fastener points
        f_projected = core.common.ProjectFastenerbyPlane(mdb.fasteners, self.projector)
        self.fastener_pos, self.shift, self.boundary = core.common.MapFastener2Scene(f_projected, mdb.boundary_margin)

        # Project and translate stringers
        stgr_pos_projected = core.common.ProjectSTGR(mdb.stringers, self.projector, view_flag)
        self.stgr_pos = core.common.TranslateSTGR(stgr_pos_projected, self.shift)

        # Filter fasteners by stringer boundary
        ids_in = core.common.FilterFastenerbySTGR(self.fastener_pos, mdb.stgr_boundary_for_fasteners[view_flag],
                                                  self.stgr_pos)
        new_f_pos = {}
        for n in ids_in:
            new_f_pos[n] = self.fastener_pos[n]
        self.fastener_pos = new_f_pos

        # Group fasteners by grid the scene
        self.fastener_grid = core.common.GridFasteners(self.fastener_pos, self.boundary, 10.0)

        # Project and translate frames
        self.fr_pos = core.common.TranslateFR(mdb.frames, self.projector, self.shift)
        fr_limits = core.common.FRLines(self.fr_pos, mdb.stgr_boundary_for_fasteners[view_flag], self.stgr_pos)

        self.fr_pos['limits'] = {}
        for n in self.fr_pos['data'].keys():
            self.fr_pos['limits'][n] = fr_limits[n]

    def RefreshView(self, view_flag):
        self.nc = mdb.ncs[mdb.current_nc_index].divergence_info
        self.RefreshData(view_flag)
        self.EmptyView()
        self.ReplotSTGR()
        self.ReplotFR()

        self.ReplotFasteners()
        # Necessary of drawing boundary marks is to be re-considered.
        # self.DrawBoundaryMark()
        self.gview.FitView(self.boundary)

    def ReplotFasteners(self):
        # This function must be executed after the scene has been cleared.
        self.fastener_items = {}
        # For unaffected fasteners
        for n in self.fastener_pos.keys():
            if not n in self.nc.affected_fasteners['ids']:
                self.fastener_items[n] = self.DrawFastener(self.fastener_pos[n], 'white', 'cross')

        # For affected fasteners
        self.af_tip_items = {}
        for n in self.nc.affected_fasteners['ids']:
            if n in self.fastener_pos.keys():
                self.fastener_items[n] = self.DrawFastener(self.fastener_pos[n], 'red', 'cross_in_circle')
                label = QGraphicsTextItem('T%d' % (self.nc.affected_fasteners['ids'].index(n) + 1))
                label.moveBy(self.fastener_pos[n][0], self.fastener_pos[n][1])
                label.setFont(QFont('Times', 26, QFont.Normal))
                rgb = self.Color2GRB('red')
                label.setDefaultTextColor(QColor(rgb[0], rgb[1], rgb[2]))
                self.gscene.addItem(label)
                self.af_tip_items[n] = [label]

    def DrawFastener(self, pos, color_flag = 'white', type_flag = 'cross'):
        # Sign type: cross, cross_in_circle, circle_on_cross, star, left_star, right_star
        #            circle
        rgb = self.Color2GRB(color_flag)
        pen=QPen()
        pen.setCapStyle(Qt.FlatCap)
        pen.setColor(QColor(rgb[0], rgb[1], rgb[2]))
        pen.setWidth(3)

        items = []
        if type_flag == 'cross':
            items.append(QGraphicsLineItem(pos[0] - mdb.radius, pos[1], pos[0] + mdb.radius, pos[1]))
            items.append(QGraphicsLineItem(pos[0], pos[1] - mdb.radius, pos[0], pos[1] + mdb.radius))
        elif type_flag == 'cross_in_circle':
            items.append(QGraphicsLineItem(pos[0] - mdb.radius, pos[1], pos[0] + mdb.radius, pos[1]))
            items.append(QGraphicsLineItem(pos[0], pos[1] - mdb.radius, pos[0], pos[1] + mdb.radius))
            items.append(QGraphicsEllipseItem(pos[0] - mdb.radius, pos[1] - mdb.radius,
                                              2.0*mdb.radius, 2.0*mdb.radius))
        for n in items:
            n.setPen(pen)
            self.gscene.addItem(n)
        return items

    def Color2GRB(self, colour_flag = 'blue'):
        if colour_flag == 'black':
            return (0, 0, 0)
        elif colour_flag == 'green':
            return (50, 205, 50)
        elif colour_flag == 'red':
            return (255, 0, 0)
        elif colour_flag == 'white':
            return (255, 255, 255)
        elif colour_flag == 'blue':
            return (30, 144, 255)
        elif colour_flag == 'orange':
            return (255,165,0)
        else:
            return (0, 0, 0)

    def ChangeFastenerItemColour(self, items, target_colour_flag = 'black'):
        rgb = self.Color2GRB(target_colour_flag)
        pen=QPen()
        pen.setCapStyle(Qt.FlatCap)
        pen.setColor(QColor(rgb[0], rgb[1], rgb[2]))
        pen.setWidth(3)

        for n in items:
            n.setPen(pen)
            if type(n)=='PyQt5.QtWidgets.QGraphicsRectItem':
                self.gscene.invalidate(n.rect())
            else:
                self.gscene.invalidate(n.boundingRect())

    def RemoveItems(self, items):
        for n in items:
            self.gscene.removeItem(n)
            if type(n)=='PyQt5.QtWidgets.QGraphicsRectItem':
                self.gscene.invalidate(n.rect())
            else:
                self.gscene.invalidate(n.boundingRect())

    def DrawBoundaryMark(self):
        line1 = QGraphicsLineItem(0, 0, 10, 0)
        line2 = QGraphicsLineItem(self.boundary[0] - 10, self.boundary[1], self.boundary[0], self.boundary[1])
        self.gscene.addItem(line1)
        self.gscene.addItem(line2)
        return

    def ReplotSTGR(self):
        # Set pen
        rgb = self.Color2GRB('orange')
        pen=QPen()
        pen.setCapStyle(Qt.FlatCap)
        pen.setColor(QColor(rgb[0], rgb[1], rgb[2]))
        pen.setStyle(Qt.DashDotLine)
        pen.setWidth(8)

        # Draw in scene
        self.stringer_items = {}
        for n in self.stgr_pos.keys():
            self.stringer_items[n] = []

            # Lines
            for m in range(0, len(self.stgr_pos[n]) - 1):
                pos = [[self.stgr_pos[n][m][0], self.stgr_pos[n][m][1]],
                       [self.stgr_pos[n][m+1][0], self.stgr_pos[n][m+1][1]]]
                line = QGraphicsLineItem(pos[0][0], pos[0][1], pos[1][0], pos[1][1])
                line.setPen(pen)
                self.stringer_items[n].append(line)
                self.gscene.addItem(line)

            # Text labels
            text = ''
            if int(n) > 0:
                text = 'STGR%d LH' %n
            else:
                text = 'STGR%d RH' %(-int(n))
            label = QGraphicsTextItem('%s' %text)
            label.moveBy(self.stgr_pos[n][0][0], self.stgr_pos[n][0][1])
            label.setFont(QFont('Times', 26, QFont.Normal))
            rgb = self.Color2GRB('white')
            label.setDefaultTextColor(QColor(rgb[0], rgb[1], rgb[2]))
            self.stringer_items[n].append(label)
            self.gscene.addItem(label)

    def ReplotFR(self):
        # Set pen
        rgb = self.Color2GRB('orange')
        pen=QPen()
        pen.setCapStyle(Qt.FlatCap)
        pen.setColor(QColor(rgb[0], rgb[1], rgb[2]))
        pen.setStyle(Qt.DashDotLine)
        pen.setWidth(8)

        # Draw in scene
        self.fr_items = {}
        for n in self.fr_pos['data'].keys():
            self.fr_items[n] = []

            # Lines
            pos = [[self.fr_pos['data'][n]['x'], self.fr_pos['limits'][n][0]],
                   [self.fr_pos['data'][n]['x'], self.fr_pos['limits'][n][1]]]
            line = QGraphicsLineItem(pos[0][0], pos[0][1], pos[1][0], pos[1][1])
            line.setPen(pen)
            self.fr_items[n].append(line)
            self.gscene.addItem(line)

            # Text labels
            label = QGraphicsTextItem('FR%d' %n)
            label.moveBy(self.fr_pos['data'][n]['x'], self.fr_pos['limits'][n][0])
            label.setFont(QFont('Times', 26, QFont.Normal))
            rgb = self.Color2GRB('white')
            label.setDefaultTextColor(QColor(rgb[0], rgb[1], rgb[2]))
            self.fr_items[n].append(label)
            self.gscene.addItem(label)

    def FindHovringOver(self, pos):
        grid_pos = [0, 0]
        for n in range(1,len(self.fastener_grid['h_divider'])):
            if pos[0] < self.fastener_grid['h_divider'][n]:
                grid_pos[0] = n-1
                break
            elif n == len(self.fastener_grid['h_divider'])-1:
                grid_pos[0] = len(self.fastener_grid['h_divider'])-1
        for n in range(1,len(self.fastener_grid['v_divider'])):
            if pos[1] < self.fastener_grid['v_divider'][n]:
                grid_pos[1] = n-1
                break
            elif n == len(self.fastener_grid['v_divider'])-1:
                grid_pos[1] = len(self.fastener_grid['v_divider'])-1
        over_id = None
        for n in self.fastener_grid['ids'][grid_pos[0]][grid_pos[1]]:
            if pos[0] >= self.fastener_pos[n][0] - mdb.radius:
                if pos[0] <= self.fastener_pos[n][0] + mdb.radius:
                    if pos[1] >= self.fastener_pos[n][1] - mdb.radius:
                        if pos[1] <= self.fastener_pos[n][1] + mdb.radius:
                            over_id = n
                            break
        return over_id

    def DoubleClickedonView(self, pos):
        id = self.FindHovringOver(pos)
        if id == None:
            return

        self.depth_dia = DepthDia(mdb.window, id)
        self.depth_dia.exec_()

    def MouseHovringAction(self, pos):
        over_id = self.FindHovringOver(pos)
        if over_id == None:
            if self.hovering_over_id == None:
                return
            else:
                self.ChangeFastenerItemColour(self.fastener_items[self.hovering_over_id], 'white')
                self.hovering_over_id = None
                self.RemoveItems(self.hovering_over_tip_items)
                self.hovering_over_tip_items = []
                return
        elif over_id in self.nc.affected_fasteners['ids']:
            return
        elif not over_id == self.hovering_over_id:
            if not self.hovering_over_id == None:
                self.ChangeFastenerItemColour(self.fastener_items[self.hovering_over_id], 'white')
                self.hovering_over_id = over_id
                self.RemoveItems(self.hovering_over_tip_items)
                self.hovering_over_tip_items = []
        self.ChangeFastenerItemColour(self.fastener_items[over_id], 'green')
        self.hovering_over_id = over_id
        label = QGraphicsTextItem('%s' % mdb.fasteners[over_id]['type'][0])
        label.moveBy(self.fastener_pos[over_id][0], self.fastener_pos[over_id][1])
        label.setFont(QFont('Times', 26, QFont.Normal))
        rgb = self.Color2GRB('green')
        label.setDefaultTextColor(QColor(rgb[0],rgb[1],rgb[2]))
        self.hovering_over_tip_items.append(label)
        self.gscene.addItem(label)

    def DepthRecevier(self, id, depth):
        if id in self.nc.affected_fasteners['ids']:
            index = self.nc.affected_fasteners['ids'].index(id)
            self.nc.affected_fasteners['depth'][index] = depth
        else:
            self.nc.affected_fasteners['ids'].append(id)
            self.nc.affected_fasteners['depth'].append(depth)
            self.RemoveItems(self.fastener_items[id])
            self.fastener_items[id] = self.DrawFastener(self.fastener_pos[id], 'red', 'cross_in_circle')
            #self.ChangeFastenerItemColour(self.fastener_items[id], 'red')
            self.hovering_over_id = None
            self.RemoveItems(self.hovering_over_tip_items)
            self.hovering_over_tip_items = []
            label = QGraphicsTextItem('T%d' %len(self.nc.affected_fasteners['ids']))
            label.moveBy(self.fastener_pos[id][0], self.fastener_pos[id][1])
            label.setFont(QFont('Times', 26, QFont.Normal))
            rgb = self.Color2GRB('red')
            label.setDefaultTextColor(QColor(rgb[0], rgb[1], rgb[2]))
            self.gscene.addItem(label)
            self.af_tip_items[id] = [label]
        self.ReplotDivTable()
        # print(self.affected_fasteners['ids'])

    def ReplotDivTable(self):
        self.div_table.clearContents()
        af_no = len(self.nc.affected_fasteners['ids'])
        if af_no >= 1:
            self.div_table.setRowCount(af_no)
            for n in range(0, af_no):
                no_item = QTableWidgetItem('T%d' %(n+1))
                self.div_table.setItem(n, 0, no_item)
                depth_item = QTableWidgetItem('%3.2f' %self.nc.affected_fasteners['depth'][n])
                self.div_table.setItem(n, 1, depth_item)
                type_item = QTableWidgetItem('%s' %mdb.fasteners[self.nc.affected_fasteners['ids'][n]]['type'][0])
                self.div_table.setItem(n, 2, type_item)
        self.div_table.resizeColumnsToContents()

    def RectangleFasteners(self, start_pos, end_pos):
        if len(self.rect_select_items) == 0:
            rgb = self.Color2GRB('red')
            pen = QPen()
            pen.setCapStyle(Qt.FlatCap)
            pen.setColor(QColor(rgb[0], rgb[1], rgb[2]))

            top_h = QGraphicsLineItem(start_pos[0], start_pos[1], end_pos[0], start_pos[1])
            bottom_h = QGraphicsLineItem(start_pos[0], end_pos[1], end_pos[0], end_pos[1])
            left_v = QGraphicsLineItem(start_pos[0], start_pos[1], start_pos[0], end_pos[1])
            right_v = QGraphicsLineItem(end_pos[0], start_pos[1], end_pos[0], end_pos[1])

            self.rect_select_items = [top_h, bottom_h, left_v, right_v]
            for n in self.rect_select_items:
                n.setPen(pen)
                self.gscene.addItem(n)
        else:
            self.rect_select_items[0].setLine(start_pos[0], start_pos[1], end_pos[0], start_pos[1])
            self.rect_select_items[1].setLine(start_pos[0], end_pos[1], end_pos[0], end_pos[1])
            self.rect_select_items[2].setLine(start_pos[0], start_pos[1], start_pos[0], end_pos[1])
            self.rect_select_items[3].setLine(end_pos[0], start_pos[1], end_pos[0], end_pos[1])
            for n in self.rect_select_items:
                self.gscene.invalidate(n.boundingRect())

    def RmoveRectangleFasteners(self):
        for n in self.rect_select_items:
            self.gscene.removeItem(n)
            self.gscene.invalidate(n.boundingRect())
        self.rect_select_items = []

    def ResultValidationCheck(self):
        if len(self.nc.affected_fasteners['ids']) == 0:
            return [-1, 'No fastener has been affected.']
        else:
            return [0,None]

class FastenerViewer(QGraphicsView):
    def __init__(self, parent):
        super(FastenerViewer, self).__init__()
        self._zoom = 0
        self._parent = parent
        self.holding = False
        self.start_pos = []
        self.setDragMode(QGraphicsView.ScrollHandDrag)
        #self.setCursor(Qt.CrossCursor)
        #QApplication.setOverrideCursor(Qt.CrossCursor)
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)
        self.setResizeAnchor(QGraphicsView.AnchorUnderMouse)

    def wheelEvent(self, event):
        if event.angleDelta().y() > 0:
            factor = 1.25
            self._zoom += 1
        else:
            factor = 0.8
            self._zoom -= 1
        if self._zoom > 0:
            self.scale(factor, factor)
        elif self._zoom == 0:
            self.scale(factor, factor)
        else:
            #self.scale(factor, factor)
            self._zoom = 0

    def FitView(self, boundary):
        rect = self.mapToScene(self.rect()).boundingRect()
        size = [rect.width(), rect.height()]
        factor = [size[0]/boundary[0], size[1]/boundary[1]]
        self.translate(-rect.x(), -rect.y())
        self.scale(min(factor), min(factor))
        #rect = self.mapToScene(self.rect()).boundingRect()
        #self.translate(-(rect.width()-boundary[0])/2, -(rect.height()-boundary[1])/2)

    def mouseMoveEvent(self, event):
        super().mouseMoveEvent(event)
        pos_obj = self.mapToScene(event.pos())
        pos_on_scene = (int(pos_obj.x()), int(pos_obj.y()))
        if not self.holding:
            self._parent.MouseHovringAction(pos_on_scene)
        else:
            self._parent.RectangleFasteners(self.start_pos, pos_on_scene)

    def mouseDoubleClickEvent(self, event):
        super().mouseDoubleClickEvent(event)
        pos_obj = self.mapToScene(event.pos())
        pos_on_scene = (int(pos_obj.x()), int(pos_obj.y()))
        self._parent.DoubleClickedonView(pos_on_scene)

    def mousePressEvent(self, event):
        super().mousePressEvent(event)
        self.holding = True
        pos_obj = self.mapToScene(event.pos())
        pos_on_scene = (int(pos_obj.x()), int(pos_obj.y()))
        self.start_pos = pos_on_scene

    def mouseReleaseEvent(self, event):
        super().mouseReleaseEvent(event)
        pos_obj = self.mapToScene(event.pos())
        pos_on_scene = (int(pos_obj.x()), int(pos_obj.y()))
        if not pos_on_scene == self.start_pos:
            self._parent.RmoveRectangleFasteners()
        self.holding = False

class DepthDia(QDialog):
    def __init__(self,parent,rivet_id):
        super(DepthDia, self).__init__(parent)
        self.setWindowFlags(self.windowFlags() & ~Qt.WindowContextHelpButtonHint)
        self.setWindowTitle('Sunken Value')

        self._parent=parent
        self._rivet_id=rivet_id

        self.DefineGUIElemnets()
        self.DrawLayout()

    def DefineGUIElemnets(self):
        self.ok_button=QPushButton('OK')
        self.ok_button.clicked.connect(self.OKButtonClicked)
        self.cancel_button=QPushButton('Cancel')
        self.cancel_button.clicked.connect(self.CancelButtonClicked)
        self.depth_edit=QLineEdit()
        self.depth_edit.setValidator(QDoubleValidator())

    def DrawLayout(self):
        top_layout=QHBoxLayout()
        top_layout.addWidget(QLabel('Please enter the sunken value (mm):'))
        top_layout.addWidget(self.depth_edit)

        button_layout=QHBoxLayout()
        button_layout.addStretch()
        button_layout.addWidget(self.ok_button)
        button_layout.addWidget(self.cancel_button)

        dia_layout=QVBoxLayout()
        dia_layout.addLayout(top_layout)
        dia_layout.addLayout(button_layout)

        self.setLayout(dia_layout)

    def OKButtonClicked(self):
        depth=float(self.depth_edit.text())
        self._parent.stack.fastener.DepthRecevier(self._rivet_id,depth)
        self.close()

    def CancelButtonClicked(self):
        self.close()

class ViewCombo(QComboBox):
    def __init__(self, parent):
        super(ViewCombo, self).__init__()
        self.parent = parent
        self.addItem('From LH')
        self.addItem('From RH')
        self.addItem('From Above')
        self.addItem('From Below')

    def ChangeView(self, index):
        self.setCurrentIndex(index)
        if index == 0:
            self.parent.RefreshView('from_left')
        elif index == 1:
            self.parent.RefreshView('from_right')
        elif index == 2:
            self.parent.RefreshView('from_top')
        elif index == 3:
            self.parent.RefreshView('from_below')

    def ChangeViewQuietly(self, index):
        self.setCurrentIndex(index)

main_window.py
#coding=utf-8

from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtCore import *
from PyQt5.QtSvg import QSvgWidget

from .. import mdb
from . import wizard_flow
from . import wp_stack
from . import msg_box

class MainWindow(QMainWindow):
    def __init__(self):
        super(MainWindow, self).__init__()
        self.setWindowTitle('XWB NC Tool')
        self.setWindowIcon(QIcon(mdb.package_path+'\\media\\icon.svg'))

    def Start(self):
        #Initialize GUI
        self.IniLayoutElements()
        self.IniLayout()

        #Set stack to first tab
        self.stack.nci.RefreshTab()
        self.stack.SetByFlag('summary')

    def IniLayoutElements(self):
        self.flow=wizard_flow.WizardFlow()
        self.stack=wp_stack.WPStack()

        self.next_page_button=QPushButton('Next')
        self.next_page_button.clicked.connect(self.NextPageButtonClicked)
        self.previous_page_button=QPushButton('Back')
        self.previous_page_button.setDisabled(True)
        self.previous_page_button.clicked.connect(self.PreviousButtonClicked)
        self.help_button = QPushButton('Help')

    def IniLayout(self):
        self.setMinimumSize(900, 600)

        logo = QSvgWidget(mdb.package_path+'\\media\\airbus_logo.svg')
        width = 200
        logo.setFixedSize(width, int(width/800*152))
        title = QLabel('A350 XWB S19 Nonconformity Tool')
        title.setFont(QFont('Times', 18, QFont.Normal))
        pallette = title.palette()
        pallette.setColor(title.foregroundRole(), QColor(25,25,112))
        title.setPalette(pallette)

        title_layout = QHBoxLayout()
        title_layout.addWidget(title)
        title_layout.addStretch()

        nav_bar_layout = QHBoxLayout()
        nav_bar_layout.addWidget(QLabel('NC Information >>> Select Fasteners >>> Generate Report'))
        nav_bar_layout.addStretch()

        top_right_layout = QVBoxLayout()
        top_right_layout.addLayout(title_layout)
        top_right_layout.addLayout(nav_bar_layout)

        top_layout = QHBoxLayout()
        top_layout.addWidget(logo)
        top_layout.addLayout(top_right_layout)

        h_separator1 = QFrame()
        h_separator1.setFrameShape(QFrame.HLine)
        h_separator1.setFrameShadow(QFrame.Sunken)

        flow_layout=QVBoxLayout()
        for n in self.flow.items:
            flow_layout.addWidget(n)
        flow_layout.addStretch()

        nav_layout = QHBoxLayout()
        nav_layout.addWidget(self.help_button)
        nav_layout.addStretch()
        nav_layout.addWidget(self.previous_page_button)
        nav_layout.addWidget(self.next_page_button)

        window_layout=QVBoxLayout()
        window_layout.addLayout(top_layout)
        h_separator = QFrame()
        h_separator.setFrameShape(QFrame.HLine)
        h_separator.setFrameShadow(QFrame.Sunken)
        window_layout.addWidget(h_separator1)
        window_layout.addWidget(self.stack)
        window_layout.addWidget(h_separator)
        window_layout.addLayout(nav_layout)

        c_widget=QWidget()
        c_widget.setLayout(window_layout)

        self.setCentralWidget(c_widget)

    def NextPageButtonClicked(self):
        if self.stack.Index2Flag(self.stack.currentIndex()) == 'nci':
            [status, flag] = self.stack.nci.ValidityCheck()
            if status==0:
                self.stack.nci.UpdateMDB()
                self.stack.fastener.RefreshView(self.stack.fastener.view)
                self.stack.SetByFlag('fastener')
                self.previous_page_button.setDisabled(False)
            else:
                warning_dia = msg_box.WarningBox(self, flag)
                warning_dia.exec_()
        elif self.stack.Index2Flag(self.stack.currentIndex()) == 'fastener':
            [status, flag] = self.stack.fastener.ResultValidationCheck()
            if status == 0:
                self.stack.SetByFlag('summary')
            else:
                warning_dia = msg_box.WarningBox(self, flag)
                warning_dia.exec_()

    def PreviousButtonClicked(self):
        if self.stack.Index2Flag(self.stack.currentIndex()) == 'fastener':
            self.stack.nci.RefreshTab()
            self.stack.SetByFlag('nci')
            self.previous_page_button.setDisabled(True)

    def MsgBoxInterface(self, status, flag):
        pass

msg_box.py
# xxx

from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtCore import *
from PyQt5.QtSvg import QSvgWidget

from .. import mdb

class WarningBox(QDialog):
    def __init__(self, parent, msg,flag=None):
        super(WarningBox, self).__init__(parent)
        self.my_parent = parent
        self.flag=flag
        self.setWindowTitle('Warning')
        self.setWindowFlags(self.windowFlags() & ~Qt.WindowContextHelpButtonHint)
        self.setMinimumSize(400, 120)
        self.DefineUIElements()
        self.msg = msg
        self.Start()

    def Start(self):
        msg = self.msg

        top_right_layout = QVBoxLayout()
        if type(msg) == type('str'):
            label = QLabel(msg)
            label.setAlignment(Qt.AlignLeft)
            top_right_layout.addWidget(label)
        elif type(msg) == type([]) or type(msg) == type((0,)):
            labels = []
            for n in msg:
                labels.append(QLabel('%s' % n))
                labels[-1].setAlignment(Qt.AlignLeft)
            for n in range(0, len(labels)):
                top_right_layout.addWidget(labels[n])
        top_right_layout.addStretch()

        label = QSvgWidget(mdb.package_path+'\\media\\warning_yellow.svg')
        label.setFixedSize(100, 100)

        top_layout = QHBoxLayout()
        top_layout.addWidget(label)
        top_layout.addLayout(top_right_layout)

        button_layout = QHBoxLayout()
        button_layout.addStretch()
        button_layout.addWidget(self.ok_button)
        button_layout.addWidget(self.cancel_button)

        dia_layout = QVBoxLayout()
        dia_layout.addLayout(top_layout)
        dia_layout.addLayout(button_layout)

        self.setLayout(dia_layout)

    def DefineUIElements(self):
        self.ok_button = QPushButton('OK')
        self.ok_button.clicked.connect(self.OKButtonClicked)
        self.ok_button.setFixedWidth(100)

        self.cancel_button = QPushButton('Cancel')
        self.cancel_button.setFixedWidth(100)
        self.cancel_button.clicked.connect(self.close)

    def OKButtonClicked(self):
        self.my_parent.MsgBoxInterface(True,self.flag)
        self.close()

class InfoBox(QDialog):
    def __init__(self, parent, msg,flag=None):
        super(InfoBox, self).__init__(parent)
        self.my_parent = parent
        self.flag=flag
        self.setWindowTitle('Information')
        self.setWindowFlags(self.windowFlags() & ~Qt.WindowContextHelpButtonHint)
        self.setMinimumSize(400, 120)
        self.DefineUIElements()
        self.msg = msg
        self.Start()

    def Start(self):
        msg = self.msg

        top_right_layout = QVBoxLayout()
        if type(msg) == type('str'):
            label = QLabel(msg)
            label.setAlignment(Qt.AlignLeft)
            top_right_layout.addWidget(label)
        elif type(msg) == type([]) or type(msg) == type((0,)):
            labels = []
            for n in msg:
                labels.append(QLabel('%s' % n))
                labels[-1].setAlignment(Qt.AlignLeft)
                labels[-1].setOpenExternalLinks(True)
            for n in range(0, len(labels)):
                top_right_layout.addWidget(labels[n])
        top_right_layout.addStretch()

        label = QSvgWidget(self.my_parent.cache_dir+'//info_blue.svg')
        label.setFixedSize(100, 100)

        top_layout = QHBoxLayout()
        top_layout.addWidget(label)
        top_layout.addLayout(top_right_layout)

        button_layout = QHBoxLayout()
        button_layout.addStretch()
        button_layout.addWidget(self.ok_button)

        dia_layout = QVBoxLayout()
        dia_layout.addLayout(top_layout)
        dia_layout.addLayout(button_layout)

        self.setLayout(dia_layout)

    def DefineUIElements(self):
        self.ok_button = QPushButton('OK')
        self.ok_button.clicked.connect(self.OKButtonClicked)
        self.ok_button.setFixedWidth(100)

    def OKButtonClicked(self):
        self.close()

nc_info_tab.py
#coding=utf-8

from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtCore import *
from PyQt5.QtSvg import QSvgWidget

from .. import mdb

class NCITab():
    def __init__(self):
        self.IniUIElements()
        self.DrawTab()

    def IniUIElements(self):
        positive_int_validator=QIntValidator()
        positive_int_validator.setBottom(0)
        self.nc_no_edit=QLineEdit()
        self.nc_no_edit.setValidator(positive_int_validator)
        self.msn_edit=QLineEdit()
        self.msn_edit.setValidator(positive_int_validator)
        self.divergence_type_combo=DivergenceTypeCombo()

        self.info_layout=QGridLayout()
        self.info_layout.addWidget(QLabel('NC Number:'),0,0)
        self.info_layout.addWidget(QLabel('MSN:'),1,0)
        self.info_layout.addWidget(QLabel('Divergence Type:'),2,0)
        self.info_layout.addWidget(self.nc_no_edit,0,1)
        self.info_layout.addWidget(self.msn_edit,1,1)
        self.info_layout.addWidget(self.divergence_type_combo,2,1)

        # For debug only
        #self.nc_no_edit.setText('1')
        #self.msn_edit.setText('1')
        #self.divergence_type_combo.setCurrentIndex(1)

    def DrawTab(self):
        cover_pic = QLabel()
        cover_pic.setPixmap(QPixmap(mdb.package_path + '\\media\\cover_pic.jpg').scaled(300, 457))

        a350 = QSvgWidget(mdb.package_path + '\\media\\Logo_Airbus_A350.svg')
        width = 300
        a350.setFixedSize(width, int(width / 800 * 105))

        content_group = QGroupBox('NC Information')
        content_layout=QVBoxLayout()
        content_layout.addLayout(self.info_layout)
        content_layout.addStretch()
        content_group.setLayout(content_layout)

        pic_layout = QVBoxLayout()
        pic_layout.addWidget(cover_pic)
        pic_layout.addStretch()
        pic_layout.addWidget(a350)

        tab_layout = QHBoxLayout()
        tab_layout.addLayout(pic_layout)
        tab_layout.addWidget(content_group)

        self.tab_widget=QWidget()
        self.tab_widget.setLayout(tab_layout)

    def ValidityCheck(self):
        if self.nc_no_edit.text()=='':
            return [-1,'Please input NC number.']
        if self.msn_edit.text()=='':
            return [-2,'Please input aircraft MSN.']
        if self.divergence_type_combo.GetCurrentTypeFlag()==None:
            return [-3,'Please select a divergence type.']
        return [0,None]

    def RefreshTab(self):
        nc=mdb.ncs[mdb.current_nc_index]
        if not nc.number==None:
            self.nc_no_edit.setText('%d' %nc.number)
        else:
            self.nc_no_edit.setText('')
        if not nc.msn==None:
            self.msn_edit.setText('%d' %nc.msn)
        else:
            self.msn_edit.setText('')
        self.divergence_type_combo.SetByFlag(nc.divergence_type)

    def UpdateMDB(self):
        nc = mdb.ncs[mdb.current_nc_index]
        nc.number = int(self.nc_no_edit.text())
        nc.msn = int(self.msn_edit.text())
        if not nc.divergence_type == self.divergence_type_combo.GetCurrentTypeFlag():
            nc.divergence_type = self.divergence_type_combo.GetCurrentTypeFlag()
            nc.SetDivergence(self.divergence_type_combo.GetCurrentTypeFlag())

class DivergenceTypeCombo(QComboBox):
    def __init__(self):
        super(DivergenceTypeCombo, self).__init__()
        self.addItem('')
        self.addItem('Too Deep Countersunk')
        self.setCurrentIndex(0)

    def GetCurrentTypeFlag(self):
        index=self.currentIndex()
        if index==0:
            return None
        elif index==1:
            return 'deep_csk'

    def SetByFlag(self,flag):
        if flag==None:
            self.setCurrentIndex(0)
        elif flag=='deep_csk':
            self.setCurrentIndex(1)

summary_tab.py

import copy
from PIL import Image

from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtCore import *

from .. import mdb
from .. import core

class SummaryTab():
    def __init__(self):
        self.IniUIElements()
        self.DrawTab()
        self.Test()

    def DrawTab(self):
        tab_layout = QVBoxLayout()
        tab_layout.addWidget(self.gview)
        self.tab_widget = QWidget()
        self.tab_widget.setLayout(tab_layout)

    def IniUIElements(self):
        self.gview = QGraphicsView()
        self.gscene = QGraphicsScene()
        self.gview.setScene(self.gscene)

    def Test(self):
        # find the fasteners
        ids = []
        for n in mdb.fasteners.keys():
            if mdb.fasteners[n]['picture'] == 'UPPER BEAM_XZ':
                if mdb.fasteners[n]['coordinate'][1] <= 0:
                    ids.append(n)
        # projection
        projected = {}
        projector = [[0, 2], ['along', 'reversed']]
        for n in ids:
            projected[n] = []
            for m in range(0, 2):
                if projector[1][m] == 'along':
                    projected[n].append(copy.deepcopy(mdb.fasteners[n]['coordinate'][projector[0][m]]))
                else:
                    projected[n].append(-copy.deepcopy(mdb.fasteners[n]['coordinate'][projector[0][m]]))
        # find evelope
        xs = []
        ys = []
        for n in ids:
            xs.append(projected[n][0])
            ys.append(projected[n][1])
        x_lim = [min(xs), max(xs)]
        y_lim = [min(ys), max(ys)]
        # find corner points
        distances = []
        for n in ids:
            dis = abs(projected[n][0]+projected[n][1] - x_lim[0] - y_lim[0])/(2.0**0.5)
            distances.append(dis)
        top_left_point_id = ids[distances.index(min(distances))]
        distances = []
        for n in ids:
            dis = abs(projected[n][0]+projected[n][1] -x_lim[1] -y_lim[1])/(2.0**0.5)
            distances.append(dis)
        bottom_right_point_id = ids[distances.index(min(distances))]
        # load the picture
        pic_path = '%s/data/Drawing_Pictures/UPPER BEAM_XZ.jpg' % mdb.package_path
        im = Image.open(pic_path)
        width, height = im.size
        print(width, height)
        picture = QPixmap(pic_path)
        image_item = QGraphicsPixmapItem()
        image_item.setPixmap(picture)
        self.gscene.addItem(image_item)
        # scale to pic
        top_left_pic = [74, 586]
        bottom_right_pic = [1578, 615]
        f_shift = {}
        for n in ids:
            f_shift[n] = [projected[n][0] - projected[top_left_point_id][0],
                          projected[n][1] - projected[top_left_point_id][1]]
        f_scaled = {}
        scale = [float(bottom_right_pic[0] - top_left_pic[0]) / float(f_shift[bottom_right_point_id][0]),
                 float(bottom_right_pic[1] - top_left_pic[1]) / float(f_shift[bottom_right_point_id][1])]
        for n in ids:
            f_scaled[n] = [f_shift[n][0]*scale[0] + top_left_pic[0], f_shift[n][1]*scale[1] + top_left_pic[1]]
        for n in ids:
            self.DrawFastener(f_scaled[n])

    def DrawFastener(self, pos, type_flag = 'cross'):
        # Sign type: cross, cross_in_circle, circle_on_cross, star, left_star, right_star
        #            circle
        rgb = [0, 0, 0]
        pen=QPen()
        pen.setCapStyle(Qt.FlatCap)
        pen.setColor(QColor(rgb[0], rgb[1], rgb[2]))
        pen.setWidth(3)

        items = []
        if type_flag == 'cross':
            items.append(QGraphicsLineItem(pos[0] - mdb.radius, pos[1], pos[0] + mdb.radius, pos[1]))
            items.append(QGraphicsLineItem(pos[0], pos[1] - mdb.radius, pos[0], pos[1] + mdb.radius))
        elif type_flag == 'cross_in_circle':
            items.append(QGraphicsLineItem(pos[0] - mdb.radius, pos[1], pos[0] + mdb.radius, pos[1]))
            items.append(QGraphicsLineItem(pos[0], pos[1] - mdb.radius, pos[0], pos[1] + mdb.radius))
            items.append(QGraphicsEllipseItem(pos[0] - mdb.radius, pos[1] - mdb.radius,
                                              2.0*mdb.radius, 2.0*mdb.radius))
        for n in items:
            n.setPen(pen)
            self.gscene.addItem(n)
        return items

wp_stack.py

from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtCore import *

from . import nc_info_tab
from. import fastener_selection_tab
from . import summary_tab

class WPStack(QStackedWidget):
    def __init__(self):
        super(WPStack, self).__init__()
        self.IniTabs()

    def IniTabs(self):
        # Index = 0, Flag = 'nci'
        self.nci = nc_info_tab.NCITab()
        self.addWidget(self.nci.tab_widget)

        # Index = 1, Flag = 'fastener'
        self.fastener = fastener_selection_tab.FastenerSelectionTab()
        self.addWidget(self.fastener.tab_widget)

        # Index = 2, Flag = 'summary'
        self.summary = summary_tab.SummaryTab()
        self.addWidget(self.summary.tab_widget)

    def Flag2Index(self, flag):
        if flag == 'nci':
            return 0
        elif flag == 'fastener':
            return 1
        elif flag == 'summary':
            return 2

    def Index2Flag(self, index):
        if index == 0:
            return 'nci'
        elif index == 1:
            return 'fastener'
        elif index == 2:
            return 'summary'

    def SetByFlag(self, flag):
        if flag == 'nci':
            self.setCurrentIndex(0)
        elif flag == 'fastener':
            self.setCurrentIndex(1)
        elif flag == 'summary':
            self.setCurrentIndex(2)

__init__.py
from . import gui
from . import mdb

#for debug
from . import core

mdb.py
"""


"""

import os

# Program version
version = (0,0,0)
window=None

#a list of nc objects
ncs=[]

#an integer of the current index of nc object in mdb.ncs
current_nc_index=0

#dic to store data of all fasteners
#fasteners[id]['coordinate']=[x,y,z]
#             ['type']=str
#             ['zone']=str
fasteners={}

#list to store x-coordinate and name of frames
#[index]['name']=str
#       ['x']=float
frames=[]

#to be defined
stringers=[]

#to be defined
zones=[]

#
boundary_margin=[50, 50]

#
neutral_z = 0.0

stgr_shown = {'from_top': [[-6, 6]],
              'from_below': [[-100, -17], [17, 100]],
              'from_left': [[5, 18]],
              'from_right': [[-18, -5]]}

stgr_boundary_for_fasteners = {'from_top': [-6, 6],
              'from_below': [17, -17],
              'from_left': [5, 18],
              'from_right': [-5, -18]}

#radius of the fastener marks in view
radius=12.5

# Absolute paths of the package and program
current_path = os.getcwd()
package_path = os.path.dirname(__file__)
