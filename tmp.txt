
import scipy.interpolate

def GetProjectorfromView(view_flag):
    '''
    This function is to define the projection parameters of
    converting the fastener coordinates from 3D absolute
    axis to 2D Graphicsview axis.
    '''

    #projector = [[two axises to remain],[direction of the two axises],
    #filter of the third axis]
    projector=[]

    if view_flag=='from_top':
        projector=[[0,1],['along','reversed'],'positive']
    elif view_flag=='from_bottom':
        projector=[[0,1],['along','along'],'negative']
    elif view_flag=='from_left':
        projector=[[0,2],['along','along'],'negative']
    elif view_flag=='from_right':
        projector=[[0,2],['reversed','along'],'positive']
    return projector

def ProjectFastenerbyPlane(fasteners,projector):
    axises=[0,1,2]
    for n in projector[0]:
        axises.remove(n)
    third_axis=axises[0]

    #f_projected['fastener_id']=[a.b]
    f_projected={}
    for n in fasteners.keys():
        validity=False
        if (projector[2]=='positive') and (fasteners[n]['coordinate'][third_axis]>=0):
            validity=True
        elif (projector[2]=='negative') and (fasteners[n]['coordinate'][third_axis]<=0):
            validity=True
        if validity:
            coordinate_projected=[fasteners[n]['coordinate'][m] for m in projector[0]]
            for m in range(0,2):
                if projector[1][m]=='reversed':
                    coordinate_projected[m]=-coordinate_projected[m]
            f_projected[n]=coordinate_projected
    return  f_projected

def ProjectSTGR(stringers,projector):
    stgr_projected={}
    for n in stringers.keys():
        stgr_projected[n]=[]
        for m in range(0,len(stringers[n])):
            point=[]
            for j in range(0,2):
                point.append(stringers[n][m][projector[0][j]])
                if projector[1][j]=='reversed':
                    point[j]=-point[j]
            stgr_projected[n].append(point)
    return stgr_projected

def FilterFastenerbySTGR(f_projected,boundary_stgr,stgr_projected):
    #boundary_stgr=[upper_stgr_str,lower_stgr_str]

    ids=f_projected.keys()
    #Step one, remove fasteners higher than the highest point
    #of the upper boundary stringer; lower than the lowest
    #point of the lower boundary stringer.
    ids_out=[]
    ys_upper=[]
    for n in range(0,len(stgr_projected[boundary_stgr[0]])):
        ys_upper.append(stgr_projected[boundary_stgr[0]][n][1])
    ys_lower=[]
    for n in range(0,len(stgr_projected[boundary_stgr[1]])):
        ys_lower.append(stgr_projected[boundary_stgr[1]][n][1])
    y_max=max(ys_upper)
    y_min=min(ys_lower)
    for n in ids:
        if f_projected[n][1]>y_max or f_projected[n][1]<y_min:
            ids_out.append(n)

    #Step two, pass fasteners between the lower point of the
    #upper boundary stringer and the upper point of the
    #lower boundary stringer.
    ids_in=[]
    y_max=min(ys_upper)
    y_min=max(ys_lower)
    for n in ids:
        if f_projected[n][1]<=y_max and f_projected[n][1]>=y_min:
            ids_in.append(n)

    #Step three, for rest of the points, check their location
    upper_boundary_curve=[[],[]]
    for n in stgr_projected[boundary_stgr[0]]:
        for m in range(0,2):
            upper_boundary_curve[m].append(n[m])
    lower_boundary_curve=[[],[]]
    for n in stgr_projected[boundary_stgr[1]]:
        for m in range(0,2):
            lower_boundary_curve[m].append(n[m])
    upper_interp=scipy.interpolate.interp1d(upper_boundary_curve[0],upper_boundary_curve[1])
    lower_interp=scipy.interpolate.interp1d(lower_boundary_curve[0],lower_boundary_curve[1])
    for n in ids_out:
        if n in ids:
            ids.remove(n)
    for n in ids_in:
        if n in ids:
            ids.remove(n)
    y_max=min(ys_upper)
    y_min=max(ys_lower)
    for n in ids:
        validity=False
        if f_projected[n][1]>=y_max:
            #fastener locates to upper half
            if f_projected[n][0]<stgr_projected[boundary_stgr[0]][0][0]:
                if f_projected[n][1]<=stgr_projected[boundary_stgr[0]][0][1]:
                    validity=True
            elif f_projected[n][0]>stgr_projected[boundary_stgr[0]][-1][0]:
                if f_projected[n][1]<=stgr_projected[boundary_stgr[0]][-1][1]:
                    validity=True
            else:
                if f_projected[n][1]<=upper_interp(f_projected[n][0]):
                    validity=True
        elif f_projected[n][1]<=y_min:
            #fastener locates at lower half
            if f_projected[n][0]<stgr_projected[boundary_stgr[1]][0][0]:
                if f_projected[n][1]>=stgr_projected[boundary_stgr[1]][0][1]:
                    validity=True
            elif f_projected[n][0]>stgr_projected[boundary_stgr[1]][-1][0]:
                if f_projected[n][1]>=stgr_projected[boundary_stgr[1]][-1][1]:
                    validity=True
            else:
                if f_projected[n][1]>=lower_interp(f_projected[n][0]):
                    validity=True
        if validity:
            ids_in.append(n)
    return ids_in

def GridFasteners(ids,f_projected,radius=10):
    #This function divides the fasteners into grids to improve
    #performance when checking the mouse hovring over action.

    grid_number=10
    #find boundaries
    
    return
